# OpenShift - Template


In this step, we will learn OpenShift CLI using the command _oc_.

Before we begin, make sure that your OpenShift is up and running. Run the folowing command to login to the OpenShift cluster
`oc login -u system:admin`{{execute}}


Next, create a dedicated project for our lab:
`oc new-project advanced`{{execute}}

#### Templates
Instead of creating resources one-by-one – for example, a pod, service, and route – templates allow you to create multiple objects at once with a single CLI command. More than that —they may include parameters that can be optional,or default to values either static or generated in accordance with specific rules.

In a sense, they are similar to Docker Compose or OpenStack Heat—all of these provide the facility to create entire application stacks from the ground up. With templates, the cluster administrator can provide developers with the ability to deploy multi-tier applications with all dependent services.

## Visualiser les templates


By default, OpenShift comes installed with quite a few default templates, called Instant App and Quick Start templates. They can be used to deploy runtime environments based on various languages and frameworks, such as Ruby on Rails (Ruby), Django (Python), and CakePHP (PHP). They also include templates for SQL and NoSQL database engines with persistent storage, which includes PersistentVolumeClaims as one of the objects to provide persistence of data.


Default templates are created in the openshift project during installation. You can see them by running the following command:


`oc get template -n openshift | cut -d' ' -f1`{{execute}}

```
NAME
3scale-gateway
amp-apicast-wildcard-router
amp-pvc
cakephp-mysql-example
cakephp-mysql-persistent
dancer-mysql-example
dancer-mysql-persistent
django-psql-example
django-psql-persistent
dotnet-example
dotnet-pgsql-persistent
dotnet-runtime-example
httpd-example
```

We used the cut command to exclude descriptions and other information for the sake of brevity, but you can run this command without cut to see the full output.


To get a list of parameters that are supported by a particular template, use the process command:
`oc process --parameters mariadb-persistent -n openshift`{{execute}}

````
NAME                   DESCRIPTION       GENERATOR       VALUE
MEMORY_LIMIT           ...                               512Mi
NAMESPACE              ...                               openshift
DATABASE_SERVICE_NAME  ...                               mariadb
MYSQL_USER             ...               expression      user[A-Z0-9]{3}
MYSQL_PASSWORD         ...               expression      [a-zA-Z0-9]{16}
MYSQL_ROOT_PASSWORD    ...               expression      [a-zA-Z0-9]{16}
MYSQL_DATABASE         ...                               sampledb
MARIADB_VERSION        ...                               10.2
VOLUME_CAPACITY        ...                               1Gi
```

**Note:** We left out descriptions of the parameters to make the output more readable.

As you may have noticed, some parameters have dynamic default values, generated by expressions loosely based on Perl Compatible Regular Expressions (PCREs).

## Commande process


The process command generates default values from all dynamic expressions, making the template definition ready to be used for creating resources, which is done either by piping its output to the create command or by running the new-app command—we will get to that in a few moments. For now, let's use that command to see a List of objects to be created:
`oc process openshift//mariadb-persistent`{{execute}}

```
{
    "kind": "List",
    "apiVersion": "v1",
    "metadata": {},
    "items": [
        {
            "apiVersion": "v1",
            "kind": "Secret",
            ...
            <output omitted>
            ...
            "stringData": {
                "database-name": "sampledb",
                "database-password": "tYuwInpmocV1Q1uy",
                "database-root-password": "icq5jd8bfFPWXbaK",
                "database-user": "userC7A"
            }
        },
        ...
        <output omitted>
        ...
    ]
}
```

**Note:** The process command allows for an alternate syntax, `<NAMESPACE>//<TEMPLATE>`. We used it here for demonstration purposes, but you are free to use the more familiar -n <NAMESPACE> notation.

The list is quite long, so we only provided an excerpt showing the Secret resource that contains all generated sensitive values that are to be used for template instantiation.

To make things clearer, let's take a look at the expressions for generating those values in the raw template definition:
`oc export template mariadb-persistent -n openshift`{{execute}}

You may have noticed, for example, that MYSQL_DATABASE is sampledb, while MYSQL_USER starts with the string user with three alphanumeric characters, just as we saw in the previous listing.

## Créer un premier template


Now, we will create our own simple template. Create a new template definition with the following contents:

<pre class="file" data-filename="example-template.yml" data-target="replace">
kind: Template
apiVersion: v1
metadata:
  name: example-template
labels:
  role: web
message: You chose to deploy ${WEB_SERVER}
objects:
  - kind: Pod
    apiVersion: v1
    metadata:
      name: example-pod
    spec:
      containers:
        - name: ${WEB_SERVER}
          image: ${WEB_SERVER}
  - kind: Service
    apiVersion: v1
    metadata:
      name: example-svc
    spec:
      ports:
        - port: 80
      selector:
        role: web
  - kind: Route
    apiVersion: v1
    metadata:
      name: example-route
    spec:
      to:
        kind: Service
        name: example-svc
parameters:
  - name: WEB_SERVER
    displayName: Web Server
    description: Web server image to use
    value: nginx
</pre>


Note
Though in our case the message parameter is used in quite a rudimentary way, in more complex templates, its purpose is to tell the user how to use the template—what usernames, passwords, URLs, and so on were generated.

This template can be used to create three resources:

- A pod running a web server, which you can choose by supplying the WEB_SERVER parameter. By default, it's nginx.
- A service proxying incoming traffic to the pod.
- A route for external access.

We can process that definition right away and pass the resulting list of resources to the create command, but a common strategy is to create a template from its definition first:
`oc create -f example-template.yml`{{execute}}

## Utiliser son propre template



Let's try to process it:
`oc process --parameters example-template`{{execute}}

```
NAME       DESCRIPTION             GENERATOR         VALUE
WEB_SERVER Web server image to use                   nginx
```

You can see the only parameter with the default value and description that you defined earlier.

Now, it's time to create a stack of resources from our template. This can be done by either piping the output of the process command to the create command, which we mentioned previously, or by using the new-app command. Let's start with the former approach:
`oc process example-template | oc create -f -`{{execute}}


As you can see, the create command just takes the list of resources and submits requests for their creation one-by-one to the API, so the output is similar to what you would see if you created three separate resource definitions and created resources from them manually.

But another way to instantiate a template gives you more information about what is going on. Let's delete the created resources first:
`oc delete all --all`{{execute}}


We don't have to delete the template as it's not going to change. Now, we can use the new-app command:
`oc new-app --template=example-template`{{execute}}

```
--> Deploying template "myproject/example-template" to project myproject

     example-template
     ---------
You chose to deploy nginx

     * With parameters:
        * Web Server=nginx

--> Creating resources ...
    pod "example-pod" created
    service "example-svc" created
    route "example-route" created
--> Success
    Access your application via route 'example-route-advanced.openshift.example.com' 
    Run 'oc status' to view your app.

`oc status
In project advanced on server https://172.24.0.11:8443

http://example-route-advanced.openshift.example.com (svc/example-svc)
  pod/example-pod runs nginx
```

As you can see, we created the pod, fronted it with the service, and exposed it through the route in just a single command. Notice that you don't need to run the oc get route  command to find out what URL your application is accessible through—it all shows in the output.

Let's see if our web server is reachable through curl:
`curl -I example-route-default.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com`{{execute}}

```
HTTP/1.1 200 OK
Server: nginx/1.15.1
```

Note
We used the -I parameter of the curl command to see only response headers, which is enough to check the responsiveness of the server and ensure that it doesn't dump raw HTML into the console. Also, just as before, we used -H option to request a specific application from OpenShift's router.

You can easily delete all of the resources and instantiate the template again, but this time with another web server image, such as Apache:
`oc delete all --all`{{execute}}


## Déployer son template


`oc new-app --template=example-template -p WEB_SERVER=httpd`{{execute}}

```
--> Deploying template "myproject/example-template" to project myproject

     example-template
     ---------
You chose to deploy httpd
...
<output omitted>
...
    Access your application via route 'example-route-advanced.openshift.example.com' 
    Run 'oc status' to view your app.
```

`curl -I example-route-advanced.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com`{{execute}}

## Rollback 

You can also perform a reverse operation—creating a template from existing resources. To do that, use the export command:
`oc export all --as-template=exported-template > exported-template.yml`{{execute}}

Let's delete our resources to prevent any conflicts:
`oc delete all --all`{{execute}}


And recreate them from the exported template:
`oc new-app -f exported-template.yml`{{execute}}

```
--> Deploying template "advanced/exported-template" for "exported-template.yml" to project advanced

--> Creating resources ...
    route "example-route" created
    pod "example-pod" created
    service "example-svc" created
--> Success
    Access your application via route 'example-route-advanced.openshift.example.com' 
    Run 'oc status' to view your app.
```

**Note:** You might have noticed that the web server was exposed through the same URL as before. This is because the exported template was created from already instantiated resources with all parameters resolved to values, so OpenShift has no way of knowing which fields were parameterized. You can also infer this from the output of the process command, which will show you that all the fields are already initialized. So, strictly speaking, this isn't a fully reverse operation, but it can be used for backups.

Now that we are finished, let's do a clean-up:
`oc delete all --all`{{execute}}

`oc delete template/example-template`{{execute}}